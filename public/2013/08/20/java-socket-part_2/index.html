<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java socket编程-数据的发送和接收 | KeepMoving</title>
  <meta name="author" content="Yong">
  
  <meta name="description" content="数据的发送和接收
TCP/IP协议是以字节的方式传输用户数据的，并没有对其进行检查和修改。 
TCP/IP协议唯一约束的是，信息必须在块（chunks）中发送和接收，而块的长度必须是8的倍数，因此，我们可以认为在TCP/IP协议中传输的信息是字节序列。 
鉴于此，我们可以进一步把信息看作是数字序列或数组，每个数字表示的大小是0~255，即00000000~11111111。">
  
  
  <meta property="og:title" content="java socket编程-数据的发送和接收"/>
  <meta property="og:site_name" content="KeepMoving"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="KeepMoving" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">KeepMoving</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="/about/">About</a><li>
    
      <li class="cell"><a class="next" href="/atom.xml">Subscribe</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
<iframe width="100%" height="100" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=110&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=0&isWeibo=0&isFans=0&uid=null&verifier=78e1ee4d&colors=ffffff,ffffff,999,000,ecfbfd&dpc=1"></iframe>
</div>

  

  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/hexo/" style="font-size: 10.00px;">hexo</a><a href="/tags/java_socket/" style="font-size: 17.50px;">java_socket</a><a href="/tags/tcpip/" style="font-size: 12.50px;">tcp/ip</a><a href="/tags/test/" style="font-size: 15.00px;">test</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2013 Yong
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">KeepMoving</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
<article class="post">
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title">java socket编程-数据的发送和接收</h1>
  

      <time datetime="2013-08-20T13:58:42.000Z"><a href="/2013/08/20/java-socket-part_2/">8月 20 2013</a></time>
      
  </header>
    <div class="entry">
      
        <h4>数据的发送和接收</h4>
<p>TCP/IP协议是以字节的方式传输用户数据的，并没有对其进行检查和修改。 
TCP/IP协议唯一约束的是，信息必须在块（chunks）中发送和接收，而块的长度必须是8的倍数，因此，我们可以认为在TCP/IP协议中传输的信息是字节序列。 
鉴于此，我们可以进一步把信息看作是数字序列或数组，每个数字表示的大小是0~255，即00000000~11111111。 
<a name="more"></a></p>
<h5>简单数据类型是如何通过套接字进行发送和接收的？</h5>
<p>传输信息时可以通过套接字将字节信息写入一个OutputStream实例中，或将其封装进一个DatagramPacket实例中，然后进行发送。 
但是这些操作所能处理的唯一数据类型是字节或字节数组。 </p>
<h5>整型类型</h5>
<p>对于基本类型:整型，发送端和接收端需要约定的几个方面： 
1. 要传输的整型字节的大小(Size),即该类型所需要的字节长度； 
   如32位机器上,byte(1字节),short（2字节）,int(4字节)，long(8字节)； 
2. 对于超过一个字节的数据类型，我们必须需要知道字节序列发送的顺序:从左到右（big-endian:高位--&gt;低位），从右到左（little-endian:低位--&gt;高位）。 
3. 所传输的数值是有符号的还是无符号的；java中的四种基本整型都是有符号的，它们的值以二进制补码的方式存储。 </p>
<p><strong>Code:</strong>怎样将消息的正确值存入字节数组？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>    public static void main(String[] args) {
        int iValue = <span class="number">8</span><span class="comment">;</span>
        short sValue = <span class="number">1</span><span class="comment">;</span>
        ByteArrayOutputStream buf = new ByteArrayOutputStream()<span class="comment">;</span>
        DataOutputStream <span class="keyword">out</span> = new DataOutputStream(buf)<span class="comment">;</span>
        try {
            // 输出流
            <span class="keyword">out</span><span class="preprocessor">.writeInt</span>(iValue)<span class="comment">;</span>
            <span class="keyword">out</span><span class="preprocessor">.writeShort</span>(sValue)<span class="comment">;</span>
            <span class="keyword">out</span><span class="preprocessor">.flush</span>()<span class="comment">;</span>
            // 使用字节数组中转
            byte[] msg = buf<span class="preprocessor">.toByteArray</span>()<span class="comment">;</span>
            // 输入流
            ByteArrayInputStream inbuf = new ByteArrayInputStream(msg)<span class="comment">;</span>
            DataInputStream din = new DataInputStream(inbuf)<span class="comment">;</span>
            // 按顺序读出
            int va = din<span class="preprocessor">.readInt</span>()<span class="comment">;</span>
            short vb = din<span class="preprocessor">.readShort</span>()<span class="comment">;</span>
            System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(<span class="string">"int ="</span> + va + <span class="string">",short="</span> + vb)<span class="comment">;</span>
        } catch (IOException e) {
            e<span class="preprocessor">.printStackTrace</span>()<span class="comment">;</span>
        }
    }
</pre></td></tr></table></figure>

<h5>字符串和文本</h5>
<p>每个String实例都对应一个字符序列（数组,char[]类型）；
一个字符在Java内部表示为一个整数，在一组符号和一组整数之间的映射称为编码字符集。 </p>
<p>Java是使用的Unicode的国际标准编码字符集来表示char型和String型值。Unicode字符集将符号映射到整数0~65535之间，更适用于国际化程序。 </p>
<ol>
<li>发送者和接收者必须在符号与整数的映射方式上达成共识，才能使用文本信息进行通信。 
对于每个整数值都比255小的一小组字符，不需要其他信息，因为其每个字符都能够作为一个单独的字节进行编码。 
对于可能超过一个字节的大整数的编码方式，就有多种方式在线路上对其进行编码，因此发送者和接收者需要统一编码方案。 
编码字符集和字符的编码方案结合起来称为字符集。 
Code:<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>String test = <span class="string">"Test!"</span><span class="comment">;</span>
byte[] strBytes = test<span class="preprocessor">.getBytes</span>()<span class="comment">;  // Default: UTF-8        </span>
byte[] strBytes2 = test<span class="preprocessor">.getBytes</span>(<span class="string">"UTF-16BE"</span>)<span class="comment">;    </span>
System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(<span class="string">"test utf-8:"</span> + new String(strBytes) + 
                      <span class="string">",test utf-16be:"</span> + new String(strBytes2))<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h5>位操作，布尔值编码</h5>
<h5>组合输入、输出流</h5>
<h5>成帧和解析，数据的接收</h5>
<p>接收者如何能够准确的找到消息的结束位置？ 
1. 基于定界符（Delimiter-based）:消息的结束由一个唯一的标记（unique marker）指出，即发送者在传输完数据后显式添加一个特殊字节序列。这个特殊标记不能再传输的数据中出现。<br>   基于定界符的方法通常用在以文本方式编码的消息中：定义一个特殊的字符或字符串来标识消息的结束。
   接收者只需要简单地扫描信息（以字节的方式）来查找定界符序列，并将定界符前面的字符串返回。<br>   缺点：发送信息中不能含有定界符，否则接收者将提前认为消息已结束。
   解决办法：填充技术（stuffing）：对消息中出现的定界符进行修改，从而使接收者不将其识别为定界符。但是该办法需要发送者和接收者都扫描发送消息，以便对消息中的定界符进行修改和恢复。 
2. 显式长度（Explicit length）:在变长字段或消息前附加一个固定大小的字段，用来指示该字段或消息中包含了多少字节。 </p>
<p>TODO：
<strong>Code：</strong> 实现基于定界符的成帧方法 
Framer.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Framer</span> {</span>
    
    <span class="comment">/*
     * Add frame message,Output info to specified OutputStream
     * 
     * */</span>
    <span class="keyword">void</span> frameMsg(<span class="keyword">byte</span>[] message, OutputStream out ) <span class="keyword">throws</span> IOException; 
    
    <span class="comment">/*
     * Return current msg before   delimiter  and get next frame message
     * 
     * */</span>
    <span class="keyword">byte</span>[] nextMsg() <span class="keyword">throws</span> IOException;
}
</pre></td></tr></table></figure>

<p>DelimFramer.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelimFramer</span> <span class="keyword">implements</span> <span class="title">Framer</span>{</span>
    <span class="keyword">private</span> InputStream in; <span class="comment">// data source</span>
    
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DELIMTER = <span class="string">'\n'</span>;  <span class="comment">//  message delimter</span>
    
    <span class="keyword">public</span> DelimFramer(InputStream in) {
        <span class="keyword">this</span>.in = in;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> frameMsg(<span class="keyword">byte</span>[] message, OutputStream out) <span class="keyword">throws</span> IOException {
        <span class="comment">// Ensure that message doesn't contain DELIMTER</span>
        <span class="keyword">for</span> (<span class="keyword">byte</span> b : message ){
            <span class="keyword">if</span> (b == DELIMTER){
                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Message contains delimiter."</span>);
            }
        }
        out.write(message);
        out.write(DELIMTER);
        out.flush();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">byte</span>[] nextMsg() <span class="keyword">throws</span> IOException {
        ByteArrayOutputStream messageBuffer = <span class="keyword">new</span> ByteArrayOutputStream();
        <span class="keyword">int</span> nextByte ; 
        <span class="comment">// fetch bytes until find DELIMTER</span>
        <span class="keyword">while</span> ((nextByte = in.read()) != DELIMTER ){
            <span class="keyword">if</span> (nextByte == -<span class="number">1</span>){
                System.out.println(<span class="string">"size:"</span> + messageBuffer.size());
                <span class="keyword">if</span>(messageBuffer.size() == <span class="number">0</span> ){
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                }
                <span class="keyword">else</span>{
                    <span class="keyword">throw</span> <span class="keyword">new</span> EOFException(<span class="string">"Non-empty message without delimter."</span>);
                }
            }
            messageBuffer.write(nextByte);
        }
        <span class="keyword">return</span> messageBuffer.toByteArray();
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        String s = <span class="string">"aaa"</span>;
        <span class="keyword">byte</span>[] b = s.getBytes();
        
        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(b);
        DelimFramer dFramer = <span class="keyword">new</span> DelimFramer(in);
        
        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();
        <span class="keyword">try</span> {
            dFramer.frameMsg(b, out);
            dFramer.nextMsg();
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}
</pre></td></tr></table></figure>

<p>基于长度成帧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthFramer</span> <span class="keyword">implements</span> <span class="title">Framer</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_MESSAGE_LENGTH = <span class="number">65535</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BYTE_MASK = <span class="number">0xff</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHORT_MASK = <span class="number">0xffff</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BYTE_SHIFT = <span class="number">8</span>;
    DataInputStream in;
    <span class="keyword">public</span> LengthFramer(InputStream in) {
        <span class="keyword">this</span>.in = <span class="keyword">new</span> DataInputStream(in);
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> frameMsg(<span class="keyword">byte</span>[] message, OutputStream out) <span class="keyword">throws</span> IOException {
        <span class="keyword">if</span> (message.length &gt; MAX_MESSAGE_LENGTH) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"message is too long."</span>);
        }
        out.write((message.length &gt;&gt; BYTE_SHIFT) & BYTE_MASK);
        out.write(message.length & BYTE_MASK);
        out.write(message);
        out.flush();
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">byte</span>[] nextMsg() <span class="keyword">throws</span> IOException {
        <span class="keyword">int</span> length;
        <span class="comment">//</span>
        length = in.readUnsignedShort();
        <span class="keyword">byte</span>[] msg = <span class="keyword">new</span> <span class="keyword">byte</span>[length];
        in.readFully(msg);
        <span class="keyword">return</span> msg;
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        String str = <span class="string">"abc"</span>;
        <span class="keyword">byte</span>[] buf = str.getBytes();
        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());
        DataInputStream input = <span class="keyword">new</span> DataInputStream(in);
        LengthFramer framer = <span class="keyword">new</span> LengthFramer(input);
        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();
        <span class="keyword">try</span> {
            <span class="comment">// framer msg.</span>
            framer.frameMsg(buf, out);
            framer.nextMsg();
        } <span class="keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}
</pre></td></tr></table></figure>

<h5>构建和解析协议</h5>
<p>这部分内容主要是介绍了对在实现别人定义的协议时可能用到的技术。</p>
<h5>Reference</h5>
<p>1.Java TCP/IP Socket编程</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="null"><strong>null</strong></a> - 8月 20 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://zhuyong.github.com"><strong>KeepMoving</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
	 
     		  
       		
  
  <div class="tags">
    <a href="/tags/java_socket/">java_socket</a>
  </div>

     		  
       	 
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


</div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="/about/">About</a></div>
    
      <div class="tabbaritem"><a class="next" href="/atom.xml">Subscribe</a></div>
    
</div>


  </div>
</body>
</html>