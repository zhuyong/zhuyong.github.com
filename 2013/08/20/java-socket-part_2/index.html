<html>
<head>
	
	<title>java socket编程-数据的发送和接收</title>
	<meta name="keywords" content="My Blog!" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<p>####数据的发送和接收<br>TCP/IP协议是以字节的方式传输用户数据的，并没有对其进行检查和修改。<br>TCP/IP协议唯一约束的是，信息必须在块（chunks）中发送和接收，而块的长度必须是8的倍数，因此，我们可以认为在TCP/IP协议中传输的信息是字节序列。<br>鉴于此，我们可以进一步把信息看作是数字序列或数组，每个数字表示的大小是0~255，即00000000~11111111。<br><a id="more"></a></p>
<p>#####简单数据类型是如何通过套接字进行发送和接收的？<br>传输信息时可以通过套接字将字节信息写入一个OutputStream实例中，或将其封装进一个DatagramPacket实例中，然后进行发送。<br>但是这些操作所能处理的唯一数据类型是字节或字节数组。 </p>
<p>#####整型类型<br>对于基本类型:整型，发送端和接收端需要约定的几个方面： </p>
<ol>
<li>要传输的整型字节的大小(Size),即该类型所需要的字节长度；<br>如32位机器上,byte(1字节),short（2字节）,int(4字节)，long(8字节)； </li>
<li>对于超过一个字节的数据类型，我们必须需要知道字节序列发送的顺序:从左到右（big-endian:高位–&gt;低位），从右到左（little-endian:低位–&gt;高位）。 </li>
<li>所传输的数值是有符号的还是无符号的；java中的四种基本整型都是有符号的，它们的值以二进制补码的方式存储。 </li>
</ol>
<p><strong>Code:</strong>怎样将消息的正确值存入字节数组？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    int iValue = 8;</div><div class="line">    short sValue = 1;</div><div class="line">    ByteArrayOutputStream buf = new ByteArrayOutputStream();</div><div class="line">    DataOutputStream out = new DataOutputStream(buf);</div><div class="line">    try &#123;</div><div class="line">        // 输出流</div><div class="line">        out.writeInt(iValue);</div><div class="line">        out.writeShort(sValue);</div><div class="line">        out.flush();</div><div class="line">        // 使用字节数组中转</div><div class="line">        byte[] msg = buf.toByteArray();</div><div class="line">        // 输入流</div><div class="line">        ByteArrayInputStream inbuf = new ByteArrayInputStream(msg);</div><div class="line">        DataInputStream din = new DataInputStream(inbuf);</div><div class="line">        // 按顺序读出</div><div class="line">        int va = din.readInt();</div><div class="line">        short vb = din.readShort();</div><div class="line">        System.out.println(&quot;int =&quot; + va + &quot;,short=&quot; + vb);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####字符串和文本<br>每个String实例都对应一个字符序列（数组,char[]类型）；<br>一个字符在Java内部表示为一个整数，在一组符号和一组整数之间的映射称为编码字符集。 </p>
<p>Java是使用的Unicode的国际标准编码字符集来表示char型和String型值。Unicode字符集将符号映射到整数0~65535之间，更适用于国际化程序。 </p>
<ol>
<li>发送者和接收者必须在符号与整数的映射方式上达成共识，才能使用文本信息进行通信。<br>对于每个整数值都比255小的一小组字符，不需要其他信息，因为其每个字符都能够作为一个单独的字节进行编码。<br>对于可能超过一个字节的大整数的编码方式，就有多种方式在线路上对其进行编码，因此发送者和接收者需要统一编码方案。<br>编码字符集和字符的编码方案结合起来称为字符集。<br>Code:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">String test = &quot;Test!&quot;;</div><div class="line">byte[] strBytes = test.getBytes();  // Default: UTF-8        </div><div class="line">byte[] strBytes2 = test.getBytes(&quot;UTF-16BE&quot;);    </div><div class="line">System.out.println(&quot;test utf-8:&quot; + new String(strBytes) + </div><div class="line">                      &quot;,test utf-16be:&quot; + new String(strBytes2));</div><div class="line">``` </div><div class="line">#####位操作，布尔值编码 </div><div class="line">#####组合输入、输出流 </div><div class="line"></div><div class="line">#####成帧和解析，数据的接收 </div><div class="line">接收者如何能够准确的找到消息的结束位置？ </div><div class="line">1. 基于定界符（Delimiter-based）:消息的结束由一个唯一的标记（unique marker）指出，即发送者在传输完数据后显式添加一个特殊字节序列。这个特殊标记不能再传输的数据中出现。  </div><div class="line">   基于定界符的方法通常用在以文本方式编码的消息中：定义一个特殊的字符或字符串来标识消息的结束。</div><div class="line">   接收者只需要简单地扫描信息（以字节的方式）来查找定界符序列，并将定界符前面的字符串返回。  </div><div class="line">   缺点：发送信息中不能含有定界符，否则接收者将提前认为消息已结束。</div><div class="line">   解决办法：填充技术（stuffing）：对消息中出现的定界符进行修改，从而使接收者不将其识别为定界符。但是该办法需要发送者和接收者都扫描发送消息，以便对消息中的定界符进行修改和恢复。 </div><div class="line">2. 显式长度（Explicit length）:在变长字段或消息前附加一个固定大小的字段，用来指示该字段或消息中包含了多少字节。 </div><div class="line"></div><div class="line">TODO：</div><div class="line">&lt;strong&gt;Code：&lt;/strong&gt; 实现基于定界符的成帧方法 </div><div class="line">Framer.java</div></pre></td></tr></table></figure>
</li>
</ol>
<p>public interface Framer {</p>
<pre><code>/*
 * Add frame message,Output info to specified OutputStream
 * 
 * */
void frameMsg(byte[] message, OutputStream out ) throws IOException; 

/*
 * Return current msg before   delimiter  and get next frame message
 * 
 * */
byte[] nextMsg() throws IOException;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DelimFramer.java</div></pre></td></tr></table></figure></p>
<p>public class DelimFramer implements Framer{<br>    private InputStream in; // data source</p>
<pre><code>private static final byte DELIMTER = &apos;\n&apos;;  //  message delimter

public DelimFramer(InputStream in) {
    this.in = in;
}

@Override
public void frameMsg(byte[] message, OutputStream out) throws IOException {
    // Ensure that message doesn&apos;t contain DELIMTER
    for (byte b : message ){
        if (b == DELIMTER){
            throw new IOException(&quot;Message contains delimiter.&quot;);
        }
    }
    out.write(message);
    out.write(DELIMTER);
    out.flush();
}
@Override
public byte[] nextMsg() throws IOException {
    ByteArrayOutputStream messageBuffer = new ByteArrayOutputStream();
    int nextByte ; 
    // fetch bytes until find DELIMTER
    while ((nextByte = in.read()) != DELIMTER ){
        if (nextByte == -1){
            System.out.println(&quot;size:&quot; + messageBuffer.size());
            if(messageBuffer.size() == 0 ){
                return null;
            }
            else{
                throw new EOFException(&quot;Non-empty message without delimter.&quot;);
            }
        }
        messageBuffer.write(nextByte);
    }
    return messageBuffer.toByteArray();
}

public static void main(String[] args) {
    String s = &quot;aaa&quot;;
    byte[] b = s.getBytes();

    ByteArrayInputStream in = new ByteArrayInputStream(b);
    DelimFramer dFramer = new DelimFramer(in);

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
        dFramer.frameMsg(b, out);
        dFramer.nextMsg();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">基于长度成帧</div></pre></td></tr></table></figure></p>
<p>public class LengthFramer implements Framer {<br>    public static final int MAX_MESSAGE_LENGTH = 65535;<br>    public static final int BYTE_MASK = 0xff;<br>    public static final int SHORT_MASK = 0xffff;<br>    public static final int BYTE_SHIFT = 8;<br>    DataInputStream in;<br>    public LengthFramer(InputStream in) {<br>        this.in = new DataInputStream(in);<br>    }<br>    @Override<br>    public void frameMsg(byte[] message, OutputStream out) throws IOException {<br>        if (message.length &gt; MAX_MESSAGE_LENGTH) {<br>            throw new IOException(“message is too long.”);<br>        }<br>        out.write((message.length &gt;&gt; BYTE_SHIFT) &amp; BYTE_MASK);<br>        out.write(message.length &amp; BYTE_MASK);<br>        out.write(message);<br>        out.flush();<br>    }<br>    @Override<br>    public byte[] nextMsg() throws IOException {<br>        int length;<br>        //<br>        length = in.readUnsignedShort();<br>        byte[] msg = new byte[length];<br>        in.readFully(msg);<br>        return msg;<br>    }<br>    public static void main(String[] args) {<br>        String str = “abc”;<br>        byte[] buf = str.getBytes();<br>        ByteArrayInputStream in = new ByteArrayInputStream(str.getBytes());<br>        DataInputStream input = new DataInputStream(in);<br>        LengthFramer framer = new LengthFramer(input);<br>        ByteArrayOutputStream out = new ByteArrayOutputStream();<br>        try {<br>            // framer msg.<br>            framer.frameMsg(buf, out);<br>            framer.nextMsg();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>```</p>
<p>#####构建和解析协议<br>这部分内容主要是介绍了对在实现别人定义的协议时可能用到的技术。</p>
<p>#####Reference<br>1.Java TCP/IP Socket编程</p>


<!--<a href="http://zhuyong.github.com/2013/08/20/java-socket-part_2/#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'null'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>







</body>
</html>